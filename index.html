<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>D20 GPU Streak Hunter</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      color: #0f0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
      text-align: center;
    }

    #stats {
      white-space: pre-line;
      line-height: 1.6;
      font-size: 1rem;
      margin-top: 0.5rem;
    }

    button {
      margin-top: 1.5rem;
      padding: 0.6rem 1rem;
      border-radius: 8px;
      border: 1px solid #0f0;
      background: #020;
      color: #0f0;
      font-size: 1rem;
      cursor: pointer;
    }

    button:active {
      background: #040;
    }
  </style>
</head>
<body>
  <h1>D20 GPU Streak Hunter</h1>
  <div id="stats">Checking WebGPU supportâ€¦</div>
  <button id="startBtn" disabled>Start GPU Rolling</button>

<script type="module">
///////////////////////////////////////////////////////////////////////////////
// CONFIG
///////////////////////////////////////////////////////////////////////////////
const TARGET_STREAK = 10;
const ROLLS_PER_BATCH = 1_000_000; // 1M rolls per GPU dispatch
const ROLLS_OFFSET = 8;            // bytes (seed + pad)

///////////////////////////////////////////////////////////////////////////////
// STATE
///////////////////////////////////////////////////////////////////////////////
let device, queue, pipeline, bindGroup, storageBuffer;
let running = false;

// streak state across batches
let currentStreak = 0;
let bestStreak = 0;
let totalRolls = 0;
let batchSeed = 1;

const statsDiv = document.getElementById("stats");
const startBtn = document.getElementById("startBtn");

///////////////////////////////////////////////////////////////////////////////
// SHADER (WGSL)
// We define a struct with explicit padding so the rolls array starts at offset 8
///////////////////////////////////////////////////////////////////////////////
const shaderCode = /* wgsl */ `
struct Data {
  seed : u32,
  _pad : u32,
  rolls: array<u32>,
};

@group(0) @binding(0)
var<storage, read_write> data : Data;

fn lcg_rand(x : u32) -> u32 {
  return 1664525u * x + 1013904223u;
}

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid : vec3<u32>) {
  let index = gid.x;
  if (index >= ${ROLLS_PER_BATCH}u) {
    return;
  }

  let r = lcg_rand(data.seed ^ index);
  data.rolls[index] = r % 20u; // 0â€“19
}
`;

///////////////////////////////////////////////////////////////////////////////
// INIT WEBGPU
///////////////////////////////////////////////////////////////////////////////
async function initWebGPU() {
  if (!("gpu" in navigator)) {
    statsDiv.textContent = "âŒ WebGPU not supported.\nUse desktop Chrome/Edge.";
    return;
  }

  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter) {
    statsDiv.textContent = "âŒ No suitable GPU adapter found.";
    return;
  }

  device = await adapter.requestDevice();
  queue = device.queue;

  const module = device.createShaderModule({ code: shaderCode });

  pipeline = device.createComputePipeline({
    layout: "auto",
    compute: {
      module,
      entryPoint: "main"
    }
  });

  // buffer size: 8 bytes header (seed + pad) + rolls
  const bufferSize = ROLLS_OFFSET + ROLLS_PER_BATCH * 4;
  storageBuffer = device.createBuffer({
    size: bufferSize,
    usage: GPUBufferUsage.STORAGE |
           GPUBufferUsage.COPY_SRC |
           GPUBufferUsage.COPY_DST
  });

  // init seed (not atomic, just per-batch)
  queue.writeBuffer(storageBuffer, 0, new Uint32Array([batchSeed]));

  bindGroup = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: storageBuffer } }
    ]
  });

  statsDiv.textContent = "âœ… WebGPU ready.\nPress Start to begin.";
  startBtn.disabled = false;
}

///////////////////////////////////////////////////////////////////////////////
// ONE GPU BATCH (ASYNC)
///////////////////////////////////////////////////////////////////////////////
async function runOneBatch() {
  if (!running) return;

  // write a new seed for this batch
  batchSeed = (batchSeed + 1) >>> 0;
  queue.writeBuffer(storageBuffer, 0, new Uint32Array([batchSeed]));

  const tStart = performance.now();

  // --- 1) Run compute shader to fill rolls buffer ---
  const encoder = device.createCommandEncoder();
  const pass = encoder.beginComputePass();
  pass.setPipeline(pipeline);
  pass.setBindGroup(0, bindGroup);

  const WORKGROUP_SIZE = 256;
  const numWorkgroups = Math.ceil(ROLLS_PER_BATCH / WORKGROUP_SIZE);
  pass.dispatchWorkgroups(numWorkgroups);
  pass.end();

  queue.submit([encoder.finish()]);
  await queue.onSubmittedWorkDone();

  // --- 2) Copy GPU buffer (rolls part) to CPU-readable buffer ---
  const readBuffer = device.createBuffer({
    size: ROLLS_PER_BATCH * 4,
    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
  });

  const copyEncoder = device.createCommandEncoder();
  copyEncoder.copyBufferToBuffer(
    storageBuffer,
    ROLLS_OFFSET,           // skip seed + pad
    readBuffer,
    0,
    ROLLS_PER_BATCH * 4
  );
  queue.submit([copyEncoder.finish()]);

  await readBuffer.mapAsync(GPUMapMode.READ);
  const view = readBuffer.getMappedRange();
  const rolls = new Uint32Array(view);

  // --- 3) Process rolls on CPU, track streaks + total ---
  let processed = 0;
  let found = false;

  for (let i = 0; i < rolls.length; i++) {
    const v = rolls[i]; // 0â€“19

    if (v === 19) {
      currentStreak++;
    } else {
      currentStreak = 0;
    }

    if (currentStreak > bestStreak) {
      bestStreak = currentStreak;
    }

    processed++;
    totalRolls++;

    if (currentStreak >= TARGET_STREAK) {
      found = true;
      // we do NOT break, so we finish the batch cleanly
    }
  }

  readBuffer.unmap();

  const tEnd = performance.now();
  const dt = (tEnd - tStart) / 1000; // seconds for this whole batch
  const rps = Math.round(processed / dt);

  statsDiv.textContent =
    `Total rolls: ${totalRolls.toLocaleString()}\n` +
    `Batch size: ${processed.toLocaleString()} rolls\n` +
    `Speed (real): ${rps.toLocaleString()} rolls/sec\n` +
    `Current streak: ${currentStreak}\n` +
    `Best streak: ${bestStreak}`;

  if (found) {
    running = false;
    alert(
      `ðŸŽ‰ HIT ${TARGET_STREAK} twenties in a row!\n` +
      `Total rolls: ${totalRolls.toLocaleString()}\n` +
      `Best streak: ${bestStreak}`
    );
    return;
  }

  if (running) {
    // small yield so browser stays happy
    setTimeout(runOneBatch, 0);
  }
}

///////////////////////////////////////////////////////////////////////////////
// BUTTON HANDLER
///////////////////////////////////////////////////////////////////////////////
startBtn.addEventListener("click", () => {
  if (!device || running) return;

  // reset global state
  currentStreak = 0;
  bestStreak = 0;
  totalRolls = 0;
  batchSeed = 1;
  running = true;

  statsDiv.textContent = "Starting GPU batchesâ€¦";
  startBtn.disabled = true;
  startBtn.textContent = "Runningâ€¦";

  runOneBatch().finally(() => {
    startBtn.disabled = false;
    startBtn.textContent = "Start GPU Rolling";
  });
});

///////////////////////////////////////////////////////////////////////////////
// KICK OFF
///////////////////////////////////////////////////////////////////////////////
initWebGPU();
</script>
</body>
</html>
