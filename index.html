<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>D20 GPU Streak Hunter</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      color: #0f0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
      text-align: center;
    }

    #stats {
      white-space: pre-line;
      line-height: 1.6;
      font-size: 1rem;
      margin-top: 0.5rem;
    }

    button {
      margin-top: 1.5rem;
      padding: 0.6rem 1rem;
      border-radius: 8px;
      border: 1px solid #0f0;
      background: #020;
      color: #0f0;
      font-size: 1rem;
      cursor: pointer;
    }

    button:active {
      background: #040;
    }
  </style>
</head>
<body>
  <h1>D20 GPU Streak Hunter</h1>
  <div id="stats">Checking WebGPU support‚Ä¶</div>
  <button id="startBtn" disabled>Start GPU Rolling</button>

<script type="module">
///////////////////////////////////////////////////////////////////////////////
// CONFIG
///////////////////////////////////////////////////////////////////////////////
const TARGET_STREAK = 10;
const ROLLS_PER_BATCH = 1_000_000; // 1M rolls per GPU dispatch

///////////////////////////////////////////////////////////////////////////////
// STATE
///////////////////////////////////////////////////////////////////////////////
let device, queue, pipeline, bindGroup, storageBuffer;
let running = false;

// streak state across batches
let currentStreak = 0;
let bestStreak = 0;
let totalRolls = 0;

const statsDiv = document.getElementById("stats");
const startBtn = document.getElementById("startBtn");

///////////////////////////////////////////////////////////////////////////////
// SHADER (WGSL)
///////////////////////////////////////////////////////////////////////////////
const shaderCode = /* wgsl */ `
struct Data {
  seed: atomic<u32>,
  rolls: array<u32>,
};

@group(0) @binding(0) var<storage, read_write> data : Data;

fn lcg_rand(x : u32) -> u32 {
  return 1664525u * x + 1013904223u;
}

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid : vec3<u32>) {
  let index = gid.x;
  if (index >= ${ROLLS_PER_BATCH}u) {
    return;
  }

  let old = atomicAdd(&data.seed, 1u);
  let r = lcg_rand(old ^ index);

  // d20: 0‚Äì19 (we treat 19 as "20")
  data.rolls[index] = r % 20u;
}
`;

///////////////////////////////////////////////////////////////////////////////
// INIT WEBGPU
///////////////////////////////////////////////////////////////////////////////
async function initWebGPU() {
  if (!("gpu" in navigator)) {
    statsDiv.textContent = "‚ùå WebGPU not supported on this device.\nUse desktop Chrome/Edge.";
    return;
  }

  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter) {
    statsDiv.textContent = "‚ùå No suitable GPU adapter found.";
    return;
  }

  device = await adapter.requestDevice();
  queue = device.queue;

  const module = device.createShaderModule({ code: shaderCode });

  pipeline = device.createComputePipeline({
    layout: "auto",
    compute: {
      module,
      entryPoint: "main"
    }
  });

  // buffer: first 4 bytes = seed, then ROLLS_PER_BATCH * 4 bytes of u32
  const bufferSize = 4 + ROLLS_PER_BATCH * 4;
  storageBuffer = device.createBuffer({
    size: bufferSize,
    usage: GPUBufferUsage.STORAGE |
           GPUBufferUsage.COPY_SRC |
           GPUBufferUsage.COPY_DST
  });

  // init seed
  const seed = new Uint32Array([Date.now() & 0xffffffff]);
  queue.writeBuffer(storageBuffer, 0, seed);

  bindGroup = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: storageBuffer } }
    ]
  });

  statsDiv.textContent = "‚úÖ WebGPU ready.\nPress Start to begin.";
  startBtn.disabled = false;
}

///////////////////////////////////////////////////////////////////////////////
// ONE GPU BATCH (ASYNC)
///////////////////////////////////////////////////////////////////////////////
async function runOneBatch() {
  if (!running) return;

  const tStart = performance.now();

  // --- 1) Run compute shader to fill rolls buffer ---
  const encoder = device.createCommandEncoder();
  const pass = encoder.beginComputePass();
  pass.setPipeline(pipeline);
  pass.setBindGroup(0, bindGroup);

  const WORKGROUP_SIZE = 256;
  const numWorkgroups = Math.ceil(ROLLS_PER_BATCH / WORKGROUP_SIZE);
  pass.dispatchWorkgroups(numWorkgroups);
  pass.end();

  queue.submit([encoder.finish()]);
  await queue.onSubmittedWorkDone();

  // --- 2) Copy GPU buffer to a CPU-readable buffer ---
  const readBuffer = device.createBuffer({
    size: ROLLS_PER_BATCH * 4,
    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
  });

  const copyEncoder = device.createCommandEncoder();
  copyEncoder.copyBufferToBuffer(
    storageBuffer,
    4,                // skip seed
    readBuffer,
    0,
    ROLLS_PER_BATCH * 4
  );
  queue.submit([copyEncoder.finish()]);

  await readBuffer.mapAsync(GPUMapMode.READ);
  const view = readBuffer.getMappedRange();
  const rolls = new Uint32Array(view);

  // --- 3) Process rolls on CPU, track streaks + total ---
  let processed = 0;
  let found = false;

  for (let i = 0; i < rolls.length; i++) {
    const v = rolls[i]; // 0‚Äì19

    // update streak
    if (v === 19) {
      currentStreak++;
    } else {
      currentStreak = 0;
    }

    if (currentStreak > bestStreak) {
      bestStreak = currentStreak;
    }

    processed++;
    totalRolls++;

    if (currentStreak >= TARGET_STREAK) {
      found = true;
      break;
    }
  }

  readBuffer.unmap();

  const tEnd = performance.now();
  const dt = (tEnd - tStart) / 1000; // seconds for GPU + transfer + CPU loop
  const rps = Math.round(processed / dt);

  statsDiv.textContent =
    `Total rolls: ${totalRolls.toLocaleString()}\n` +
    `Batch size: ${processed.toLocaleString()} rolls\n` +
    `Speed (real): ${rps.toLocaleString()} rolls/sec\n` +
    `Current streak: ${currentStreak}\n` +
    `Best streak: ${bestStreak}`;

  if (found) {
    running = false;
    alert(
      `üéâ HIT ${TARGET_STREAK} twenties in a row!\n` +
      `Total rolls: ${totalRolls.toLocaleString()}\n` +
      `Best streak: ${bestStreak}`
    );
    return;
  }

  // --- 4) Schedule next batch if still running ---
  if (running) {
    // let the event loop breathe a tiny bit
    setTimeout(runOneBatch, 0);
  }
}

///////////////////////////////////////////////////////////////////////////////
// BUTTON HANDLER
///////////////////////////////////////////////////////////////////////////////
startBtn.addEventListener("click", () => {
  if (!device || running) return;

  // reset global state
  currentStreak = 0;
  bestStreak = 0;
  totalRolls = 0;
  running = true;

  statsDiv.textContent = "Starting GPU batches‚Ä¶";
  startBtn.disabled = true;
  startBtn.textContent = "Running‚Ä¶";

  runOneBatch().finally(() => {
    startBtn.disabled = false;
    startBtn.textContent = "Start GPU Rolling";
  });
});

///////////////////////////////////////////////////////////////////////////////
// KICK OFF
///////////////////////////////////////////////////////////////////////////////
initWebGPU();
</script>
</body>
</html>
