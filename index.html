<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>D20 GPU Streak Hunter</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      color: #0f0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
      text-align: center;
    }

    #stats {
      white-space: pre-line;
      line-height: 1.6;
      font-size: 1rem;
    }

    button {
      margin-top: 1.5rem;
      padding: 0.6rem 1rem;
      border-radius: 8px;
      border: 1px solid #0f0;
      background: #020;
      color: #0f0;
      font-size: 1rem;
    }

    button:active {
      background: #040;
    }
  </style>
</head>
<body>
  <h1>D20 GPU Streak Hunter</h1>
  <div id="stats">Checking WebGPU support‚Ä¶</div>
  <button id="startBtn" disabled>Start GPU Rolling</button>

<script type="module">
const TARGET_STREAK = 10;
const ROLLS_PER_DISPATCH = 1_000_000;   // 1M GPU rolls per batch

let device, queue, pipeline, bindGroup, storageBuffer;
let streak = 0;
let bestStreak = 0;
let totalRolls = 0;
let running = false;

const statsDiv = document.getElementById("stats");
const startBtn = document.getElementById("startBtn");

// WGSL compute shader: fast RNG
const shaderCode = `
struct Data {
  seed: atomic<u32>,
  rolls: array<u32>,
};

@group(0) @binding(0) var<storage, read_write> data : Data;

// Simple LCG RNG (fast, not cryptographically secure)
fn lcg_rand(x : u32) -> u32 {
  return 1664525u * x + 1013904223u;
}

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid : vec3<u32>) {
  let index = gid.x;
  if (index >= ${ROLLS_PER_DISPATCH}u) { return; }

  let old = atomicAdd(&data.seed, 1u);
  let r = lcg_rand(old ^ index);
  data.rolls[index] = r % 20u; // 0‚Äì19
}
`;

async function initWebGPU() {
  if (!("gpu" in navigator)) {
    statsDiv.textContent = "‚ùå WebGPU not supported on this device.\nUse Chrome/Edge on desktop.";
    return;
  }

  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter) {
    statsDiv.textContent = "‚ùå No GPU adapter available.";
    return;
  }

  device = await adapter.requestDevice();
  queue = device.queue;

  const module = device.createShaderModule({ code: shaderCode });

  pipeline = device.createComputePipeline({
    layout: "auto",
    compute: { module, entryPoint: "main" }
  });

  const bufferSize = 4 + ROLLS_PER_DISPATCH * 4; // seed + array
  storageBuffer = device.createBuffer({
    size: bufferSize,
    usage: GPUBufferUsage.STORAGE |
           GPUBufferUsage.COPY_SRC |
           GPUBufferUsage.COPY_DST
  });

  // Initialize seed
  const seed = new Uint32Array([ Date.now() & 0xffffffff ]);
  queue.writeBuffer(storageBuffer, 0, seed);

  bindGroup = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [{ binding: 0, resource: { buffer: storageBuffer } }]
  });

  statsDiv.textContent = "WebGPU Ready.\nPress Start to begin.";
  startBtn.disabled = false;
}

async function gpuRollBatch() {
  // Encode GPU commands
  const encoder = device.createCommandEncoder();
  const pass = encoder.beginComputePass();
  pass.setPipeline(pipeline);
  pass.setBindGroup(0, bindGroup);

  const WGS = 256;
  pass.dispatchWorkgroups(Math.ceil(ROLLS_PER_DISPATCH / WGS));
  pass.end();
  queue.submit([encoder.finish()]);
  await queue.onSubmittedWorkDone();

  // Read back results
  const readBuffer = device.createBuffer({
    size: ROLLS_PER_DISPATCH * 4,
    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
  });

  const copyEncoder = device.createCommandEncoder();
  copyEncoder.copyBufferToBuffer(storageBuffer, 4, readBuffer, 0, ROLLS_PER_DISPATCH * 4);
  queue.submit([copyEncoder.finish()]);

  await readBuffer.mapAsync(GPUMapMode.READ);
  const array = new Uint32Array(readBuffer.getMappedRange());

  // CPU process the rolls
  const t0 = performance.now();
  for (let i = 0; i < array.length; i++) {
    totalRolls++;
    if (array[i] === 19) streak++;
    else streak = 0;

    if (streak > bestStreak) bestStreak = streak;

    if (streak >= TARGET_STREAK) {
      running = false;
      alert(
        `üéâ HIT ${TARGET_STREAK} twenties in a row!\n` +
        `Total rolls: ${totalRolls.toLocaleString()}\n` +
        `Best streak: ${bestStreak}`
      );
      break;
    }
  }
  const t1 = performance.now();

  const dt = (t1 - t0) / 1000;
  const rps = Math.round(ROLLS_PER_DISPATCH / dt);

  statsDiv.textContent =
    `Total rolls: ${totalRolls.toLocaleString()}\n` +
    `Batch: ${ROLLS_PER_DISPATCH.toLocaleString()} rolls\n` +
    `Speed: ${rps.toLocaleString()} rolls/sec (GPU)\n` +
    `Current streak: ${streak}\n` +
    `Best streak: ${bestStreak}`;

  readBuffer.unmap();

  if (running) gpuRollBatch();
}

startBtn.addEventListener("click", () => {
  if (running) return;
  running = true;

  streak = 0;
  bestStreak = 0;
  totalRolls = 0;
  startBtn.disabled = true;
  startBtn.textContent = "Running‚Ä¶";

  gpuRollBatch().finally(() => {
    startBtn.disabled = false;
    startBtn.textContent = "Start GPU Rolling";
  });
});

initWebGPU();
</script>
</body>
</html>
