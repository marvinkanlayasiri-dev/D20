<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>D20 GPU Streak Hunter (Fixed)</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      color: #0f0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
      text-align: center;
    }

    #stats {
      white-space: pre-line;
      line-height: 1.6;
      font-size: 1rem;
    }

    button {
      margin-top: 1.5rem;
      padding: 0.6rem 1rem;
      border-radius: 8px;
      border: 1px solid #0f0;
      background: #020;
      color: #0f0;
      font-size: 1rem;
    }

    button:active {
      background: #040;
    }
  </style>
</head>
<body>
  <h1>D20 GPU Streak Hunter</h1>
  <div id="stats">Checking WebGPU support‚Ä¶</div>
  <button id="startBtn" disabled>Start GPU Rolling</button>

<script type="module">
////////////////////////////////////////////////////////////////////////////////
// CONFIG
////////////////////////////////////////////////////////////////////////////////
const TARGET_STREAK = 10;
const ROLLS_PER_DISPATCH = 1_000_000;  // 1M per GPU batch

////////////////////////////////////////////////////////////////////////////////
// PAGE STATE
////////////////////////////////////////////////////////////////////////////////
let device, queue, pipeline, bindGroup, storageBuffer;
let streak = 0;       // carry-over streak across batches
let bestStreak = 0;   // longest streak found
let totalRolls = 0;   // number of rolls processed
let running = false;

const statsDiv = document.getElementById("stats");
const startBtn = document.getElementById("startBtn");

////////////////////////////////////////////////////////////////////////////////
// GPU SHADER
////////////////////////////////////////////////////////////////////////////////
const shaderCode = `
struct Data {
  seed: atomic<u32>,
  rolls: array<u32>,
};

@group(0) @binding(0) var<storage, read_write> data : Data;

fn lcg_rand(x : u32) -> u32 {
  return 1664525u * x + 1013904223u;
}

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid : vec3<u32>) {
  let index = gid.x;
  if (index >= ${ROLLS_PER_DISPATCH}u) { return; }

  let old = atomicAdd(&data.seed, 1u);
  let r = lcg_rand(old ^ index);
  data.rolls[index] = r % 20u;
}
`;

////////////////////////////////////////////////////////////////////////////////
// INIT WEBGPU
////////////////////////////////////////////////////////////////////////////////
async function initWebGPU() {
  if (!("gpu" in navigator)) {
    statsDiv.textContent = "‚ùå WebGPU not supported.\nUse Chrome/Edge on desktop.";
    return;
  }

  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter) {
    statsDiv.textContent = "‚ùå No GPU adapter available.";
    return;
  }

  device = await adapter.requestDevice();
  queue = device.queue;

  const module = device.createShaderModule({ code: shaderCode });
  pipeline = device.createComputePipeline({
    layout: "auto",
    compute: { module, entryPoint: "main" }
  });

  const bufferSize = 4 + ROLLS_PER_DISPATCH * 4;
  storageBuffer = device.createBuffer({
    size: bufferSize,
    usage: GPUBufferUsage.STORAGE |
           GPUBufferUsage.COPY_SRC |
           GPUBufferUsage.COPY_DST
  });

  // initialize seed
  queue.writeBuffer(storageBuffer, 0, new Uint32Array([Date.now()]));

  bindGroup = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [{ binding: 0, resource: { buffer: storageBuffer } }]
  });

  statsDiv.textContent = "WebGPU detected.\nPress Start.";
  startBtn.disabled = false;
}

////////////////////////////////////////////////////////////////////////////////
// GPU ROLL LOOP
////////////////////////////////////////////////////////////////////////////////
async function gpuRollBatch() {
  if (!running) return;

  // TIME GPU COMPUTE ONLY ‚Äî REAL SPEED
  const gpuStart = performance.now();

  // run compute shader
  const encoder = device.createCommandEncoder();
  const pass = encoder.beginComputePass();
  pass.setPipeline(pipeline);
  pass.setBindGroup(0, bindGroup);

  const WGS = 256;
  pass.dispatchWorkgroups(Math.ceil(ROLLS_PER_DISPATCH / WGS));
  pass.end();
  queue.submit([encoder.finish()]);
  await queue.onSubmittedWorkDone();

  const gpuEnd = performance.now();
  const gpuSec = (gpuEnd - gpuStart) / 1000;

  // read results
  const readBuffer = device.createBuffer({
    size: ROLLS_PER_DISPATCH * 4,
    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
  });

  const copyEncoder = device.createCommandEncoder();
  copyEncoder.copyBufferToBuffer(storageBuffer, 4, readBuffer, 0, ROLLS_PER_DISPATCH * 4);
  queue.submit([copyEncoder.finish()]);
  await readBuffer.mapAsync(GPUMapMode.READ);

  // process rolls WITH STREAK CARRY-OVER FIX
  const rolls = new Uint32Array(readBuffer.getMappedRange());
  for (let i = 0; i < rolls.length; i++) {
    totalRolls++;

    if (rolls[i] === 19) {
      streak++;
    } else {
      streak = 0;
    }

    if (streak > bestStreak)
      bestStreak = streak;

    if (streak >= TARGET_STREAK) {
      running = false;
      alert(`üéâ HIT ${TARGET_STREAK} twenties!\nTotal rolls: ${totalRolls.toLocaleString()}`);
      break;
    }
  }

  readBuffer.unmap();

  // REAL GPU SPEED
  const realRPS = Math.round(ROLLS_PER_DISPATCH / gpuSec);

  statsDiv.textContent =
    `Total rolls: ${totalRolls.toLocaleString()}\n` +
    `GPU speed: ${realRPS.toLocaleString()} sec\n` +
    `Current streak: ${streak}\n` +
    `Best streak: ${bestStreak}`;

  if (running) gpuRollBatch();
}

////////////////////////////////////////////////////////////////////////////////
// BUTTON
////////////////////////////////////////////////////////////////////////////////
startBtn.addEventListener("click", () => {
  if (running) return;

  streak = 0;
  bestStreak = 0;
  totalRolls = 0;
  running = true;

  startBtn.disabled = true;
  startBtn.textContent = "Running‚Ä¶";

  gpuRollBatch().finally(() => {
    startBtn.disabled = false;
    startBtn.textContent = "Start GPU Rolling";
  });
});

////////////////////////////////////////////////////////////////////////////////
// START
////////////////////////////////////////////////////////////////////////////////
initWebGPU();
</script>
</body>
</html>
